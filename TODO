Autowrap TODO
=============

- Internal code generator refactor

  Consider splitting `CodeGenerator` into smaller, focused classes
  (e.g. for class generation, iterator support, reference handling)
  to improve maintainability and make future extensions easier.

- Improved iterator support

  Support parameterized iterator ranges (e.g. methods like
  `beginRT(rtmin)` / `endRT(rtmax)` annotated with `wrap-iter-begin`
  / `wrap-iter-end`) and expose them as dedicated Python iterator or
  range methods instead of only supporting parameterless `begin()` /
  `end()`.

- Reference semantics for methods returning references

  For methods that return references to other wrapped objects, explore
  using holder / proxy objects (using the existing
  `AutowrapRefHolder` / `AutowrapPtrHolder` infrastructure) to model
  true reference semantics, rather than always copying values into new
  wrapper instances. The goals are:

  - Preserve the lifetime of the referred-to object safely.
  - Allow attribute/method access on the referenced object to affect
    the original C++ object where appropriate.

- Safe wrapping of non-const iterators

  Investigate iterator wrappers that store both a reference to the
  original container and the iterator state, so that in-place
  modifications through iterator access are reflected in the
  underlying C++ container (instead of always iterating over copies).

